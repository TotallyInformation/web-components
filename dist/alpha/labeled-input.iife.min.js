(()=>{var u=class o extends HTMLElement{static baseVersion="2025-09-19";static _iCount=0;uib=!!window.uibuilder;uibuilder=window.uibuilder;$;$$;connected=!1;name;opts={};static get version(){return`${this.componentVersion} (Base: ${this.baseVersion})`}constructor(){super()}config(e){return e&&(this.opts=o.deepAssign(this.opts,e)),this.opts}createShadowSelectors(){this.$=this.shadowRoot?.querySelector.bind(this.shadowRoot),this.$$=this.shadowRoot?.querySelectorAll.bind(this.shadowRoot)}static deepAssign(e,...t){for(let i of t)for(let s in i){let n=i[s],r=e[s];if(Object(n)==n&&Object(r)===r){e[s]=o.deepAssign(r,n);continue}e[s]=i[s]}return e}async doInheritStyles(){if(!this.shadowRoot||!this.hasAttribute("inherit-style"))return;let e=this.getAttribute("inherit-style");e||(e="./index.css");let t=document.createElement("link");t.setAttribute("type","text/css"),t.setAttribute("rel","stylesheet"),t.setAttribute("href",e),this.shadowRoot.appendChild(t),console.info(`[${this.localName}] Inherit-style requested. Loading: "${e}"`)}ensureId(){this.uib=!!window.uibuilder,this.id||(this.id=`${this.localName}-${++this.constructor._iCount}`)}hasSlotContent(){return this.shadowRoot.querySelector("slot").assignedNodes().some(i=>i.nodeType===Node.ELEMENT_NODE?!0:i.nodeType===Node.TEXT_NODE?i.textContent.trim().length>0:!1)}prependStylesheet(e,t=0){if(!e)throw new Error(`[${this.localName}] cssText must be provided`);let i=this._findExistingStylesheet();if(i)return i;let s=document.createElement("style");return s.textContent=e,s.setAttribute("data-component",this.localName),s.setAttribute("data-order",t.toString()),this._prependToDocumentHead(s,t),s}uibSend(e,t){this.uib&&(this.uibuilder.ioConnected?this.uibuilder.send({topic:`${this.localName}:${e}`,payload:t,id:this.id,name:this.name}):console.warn(`[${this.localName}] uibuilder not connected to server, cannot send:`,e,t))}_connect(){this.ensureId(),this.doInheritStyles(),this.uib&&this.uibuilder.onTopic(`${this.localName}::${this.id}`,this._uibMsgHandler.bind(this))}_construct(e,t){e&&(t||(t={mode:"open",delegatesFocus:!0}),this.attachShadow(t).append(e),this.createShadowSelectors())}_disconnect(){document.removeEventListener(`uibuilder:msg:_ui:update:${this.id}`,this._uibMsgHandler),this._event("disconnected")}_event(e,t){this.dispatchEvent(new CustomEvent(`${this.localName}:${e}`,{bubbles:!0,composed:!0,detail:{id:this.id,name:this.name,data:t}}))}_ready(){this.connected=!0,this._event("connected"),this._event("ready")}_uibMsgHandler(e){if(typeof e.payload!="object"){console.warn(`[${this.localName}] Ignoring msg, payload is not an object:`,e);return}Object.keys(e.payload).forEach(t=>{t.startsWith("_")||(this[t]=e.payload[t])})}_findExistingStylesheet(){return document.head.querySelector(`style[data-component="${this.localName}"]`)}_prependToDocumentHead(e,t){let i=document.head,s=Array.from(i.querySelectorAll("style[data-component]"));if(s.length===0){let r=i.firstChild;r?i.insertBefore(e,r):i.appendChild(e);return}let n=null;for(let r of s){let a=parseInt(r.getAttribute("data-order")??"0",10);if(t<a){n=r;break}}if(n)i.insertBefore(e,n);else{let a=s[s.length-1].nextSibling;a?i.insertBefore(e,a):i.appendChild(e)}}},c=u;var h="2025-09-19",p=`
    input-group {
        display: block;
        
        /* Optional classes to change layout - pass down to children */
        &.above {
            --labeled-input-areas: "label" "input" "error";
            --labeled-input-columns: 1fr;
        }
        
        &.left {
            --labeled-input-areas: "label input" "error error";
            --labeled-input-justify: start;
            --labeled-input-columns: minmax(0, 1fr) 1.5fr;
        }
        
        &.right {
            --labeled-input-areas: "input label" "error error";
            --labeled-input-columns: minmax(0, 0.25fr) 2fr;
        }
        
        &.below {
            --labeled-input-areas: "input" "label" "error";
            --labeled-input-columns: 1fr;
        }
    }

    labeled-input {
        /* Default grid layout */
        display: grid;
        grid-template-areas: var(--labeled-input-areas, "label" "input" "error");
        align-items: center;
        row-gap: var(--input-grid-row-gap, var(--input-grid-gap, 0.5em));
        column-gap: var(--input-grid-column-gap, var(--input-grid-gap, 2em));
        justify-content: var(--labeled-input-justify, normal);
        grid-template-columns: var(--labeled-input-columns, 1fr);

        /* Optional classes to change layout when standalone */
        &.above {
            --labeled-input-areas: "label" "input" "error";
            --labeled-input-columns: 1fr;
        }
        &.left {
            --labeled-input-areas: "label input" "error error";
            --labeled-input-justify: start;
            --labeled-input-columns: minmax(0, 1fr) 1.5fr;
        }
        &.right {
            --labeled-input-areas: "input label" "error error";
            --labeled-input-columns: minmax(0, 0.25fr) 2fr;
        }
        &.below {
            --labeled-input-areas: "input" "label" "error";
            --labeled-input-columns: 1fr;
        }

        /* Element styles */
        & label {
            grid-area: label;
            font-weight: bold;
            line-height: 1.4;
            word-wrap: break-word;
            hyphens: auto;

            &:before {
                content: var(--label-before-content, '');
            }
            &:after {
                content: var(--label-after-content, '');
            }
        }
        
        & input {
            grid-area: input;
            border: 1px solid var(--text3);
            
            /* Better alignment for left/right layouts */
            /* :is(.left, .right) & {
                margin-top: 2px;
            } */
        }
        
        & input[type="checkbox"], & input[type="radio"] {
            justify-self: start;
            :is(.left) & {
                --labeled-input-columns: 2em auto;
            }
            :is(.right) & {
                justify-self: end;
                --labeled-input-columns: auto 2em;
            }
        }
        
        & error-message {
            display: none;
            grid-area: error;
            color: red;
            font-size: 0.9em;
        }
    }
`;var l=class extends c{static componentVersion=h;elInput;elLabel;elErrorMessage;oldValues={};static get observedAttributes(){return["inherit-style","name","type","value","placeholder","disabled","readonly","required","min","max","minlength","maxlength","size","autocomplete","autofocus","form","list","pattern","step","multiple"]}constructor(){super(),this.prependStylesheet(p,0);let e=Array.from(this.childNodes);this.innerHTML=`
            <label for="input"></label>
            <input type="text" />
            <error-message></error-message>
        `,this.elInput=this.querySelector("input"),this.elInput.id=`${this.id}-input`,this.elInput.setAttribute("name",`${this.id}-input`),this.elLabel=this.getElementsByTagName("LABEL")[0],this.elLabel.setAttribute("for",this.elInput.id),e.length>0&&(this.elLabel.innerHTML="",this.elLabel.append(...e)),this.elErrorMessage=this.querySelector("error-message")}connectedCallback(){this._connect();let e=this.closest("input-group");e&&(e.id||e.name)&&this.elInput.setAttribute("name",e.id||e.name),this._ready()}disconnectedCallback(){this._disconnect()}attributeChangedCallback(e,t,i){if(t!==i){switch(this[e]=i,this.oldValues[e]=t,e){case"inherit-style":break;case"type":{this._updateType(i);break}default:{this.elInput?.setAttribute(e,i);break}}this._event("attribChanged",{attribute:e,newVal:i,oldVal:t})}}_updateType(e){this.elInput?.setAttribute("type",e||"text")}};var d=class extends c{static componentVersion=h;static get observedAttributes(){return["inherit-style","name","type","title","frame-title","form-title"]}constructor(){super()}connectedCallback(){this._connect(),this._ready()}disconnectedCallback(){this._disconnect()}attributeChangedCallback(e,t,i){if(t!==i){switch(this[e]=i,e){case"type":{this._updateType(i);break}case"title":case"frame-title":case"form-title":{this._updateTitle(i);break}default:break}this._event("attribChanged",{attribute:e,newVal:i,oldVal:t})}}_updateType(e){if(!e)return;let t=Array.from(this.childNodes);["fieldset","frame"].includes(e)?(this.innerHTML=`
                <fieldset title="">
                    <legend></legend>
                </fieldset>
            `,this.elFrame=this.querySelector("fieldset")):e==="form"&&(this.innerHTML=`
                <form title="">
                    <div></div>
                </form>
            `,this.elFrame=this.querySelector("form")),this.elFrame&&t.length>0&&this.elFrame.append(...t)}_updateTitle(e){if(!e||!this.elFrame)return;this.title=e;let t=this.elFrame.querySelector("div")||this.elFrame.querySelector("legend");console.log("el",t,this.elFrame),t.innerText=e}},f=l;window.labeledInput=l;window.InputGroup=d;customElements.define("labeled-input",l);customElements.define("input-group",d);})();
/**
 * @class
 * @augments TiBaseComponent
 * @description Define a new zero dependency custom web component ECMA module that can be used as an HTML tag.
 *   Provides a standardised labeled input field with built-in support for various input types and error messaging.
 *
 * @element labeled-input
 * @memberOf PreAlpha
 * @license Apache-2.0

 * METHODS FROM BASE: (see TiBaseComponent)
 * STANDARD METHODS:
  * @function attributeChangedCallback Called when an attribute is added, removed, updated or replaced
  * @function connectedCallback Called when the element is added to a document
  * @function constructor Construct the component
  * @function disconnectedCallback Called when the element is removed from a document

 * OTHER METHODS:
  * None

 * CUSTOM EVENTS:
  * "labeled-input:connected" - When an instance of the component is attached to the DOM. `evt.details` contains the details of the element.
  * "labeled-input:ready" - Alias for connected. The instance can handle property & attribute changes
  * "labeled-input:disconnected" - When an instance of the component is removed from the DOM. `evt.details` contains the details of the element.
  * "labeled-input:attribChanged" - When a watched attribute changes. `evt.details.data` contains the details of the change.
  * NOTE that listeners can be attached either to the `document` or to the specific element instance.

 * Standard watched attributes (common across all my components):
  * @property {string|boolean} inherit-style - Optional. Load external styles into component (only useful if using template). If present but empty, will default to './index.css'. Optionally give a URL to load.
  * @property {string} name - Optional. HTML name attribute. Included in output _meta prop.

 * Other watched attributes:
  * None

 * PROPS FROM BASE: (see TiBaseComponent)
 * OTHER STANDARD PROPS:
  * @property {string} componentVersion Static. The component version string (date updated). Also has a getter that returns component and base version strings.

 * Other props:
  * By default, all attributes are also created as properties

 NB: properties marked with ðŸ’« are dynamic and have getters/setters.

 * @slot Container contents

 * @example
  * <labeled-input name="myComponent" inherit-style="./myComponent.css"></labeled-input>

 * See https://github.com/runem/web-component-analyzer?tab=readme-ov-file#-how-to-document-your-components-using-jsdoc
 */
/**
 * @class
 * @augments TiBaseComponent
 * @description Define a new zero dependency custom web component ECMA module that can be used as an HTML tag.
 *   Serves as a container for grouping multiple input elements together.
 *
 * @element input-group
 * @memberOf PreAlpha
 * @license Apache-2.0

 * METHODS FROM BASE: (see TiBaseComponent)
 * STANDARD METHODS:
  * @function attributeChangedCallback Called when an attribute is added, removed, updated or replaced
  * @function connectedCallback Called when the element is added to a document
  * @function constructor Construct the component
  * @function disconnectedCallback Called when the element is removed from a document

 * OTHER METHODS:
  * None

 * CUSTOM EVENTS:
  * "input-group:connected" - When an instance of the component is attached to the DOM. `evt.details` contains the details of the element.
  * "input-group:ready" - Alias for connected. The instance can handle property & attribute changes
  * "input-group:disconnected" - When an instance of the component is removed from the DOM. `evt.details` contains the details of the element.
  * "input-group:attribChanged" - When a watched attribute changes. `evt.details.data` contains the details of the change.
  * NOTE that listeners can be attached either to the `document` or to the specific element instance.

 * Standard watched attributes (common across all my components):
  * @property {string|boolean} inherit-style - Optional. Load external styles into component (only useful if using template). If present but empty, will default to './index.css'. Optionally give a URL to load.
  * @property {string} name - Optional. HTML name attribute. Included in output _meta prop.

 * Other watched attributes:
  * None

 * PROPS FROM BASE: (see TiBaseComponent)
 * OTHER STANDARD PROPS:
  * @property {string} componentVersion Static. The component version string (date updated). Also has a getter that returns component and base version strings.

 * Other props:
  * By default, all attributes are also created as properties

 NB: properties marked with ðŸ’« are dynamic and have getters/setters.

 * @slot Container contents

 * @example
  * <input-group name="myComponent" inherit-style="./myComponent.css"></input-group>

 * See https://github.com/runem/web-component-analyzer?tab=readme-ov-file#-how-to-document-your-components-using-jsdoc
 */
//# sourceMappingURL=labeled-input.iife.min.js.map
